// Copyright (C) 2013, Martin Kallman
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef SIGNALS_CPP_H_
#define SIGNALS_CPP_H_

#include <unordered_map>
#include <functional>

namespace SPP {

template<typename... T>
class Signal {
  public:
    typedef Signal<T...> type;
    typedef std::function<void(T...)> slot_type;
    typedef void (*target_type)(T...);

    class Disposable {
        friend class Signal;
        std::size_t target;
        bool is_lambda;
    };

  private:
    typedef std::unordered_map<std::size_t, slot_type> slot_map_type;
    mutable slot_map_type slots;
    mutable slot_map_type lambda_slots;
    mutable std::size_t lambda_counter;

  public:
    Signal() : lambda_counter(0) {}
    ~Signal() {}

    Disposable Add(slot_type slot) const {
        Disposable disposable;
        
        auto target = slot.template target<target_type>();

        if(target == 0) {
            auto lambda_id = lambda_counter++;
            lambda_slots.insert(typename slot_map_type::value_type(lambda_id, slot));

            disposable.target = lambda_id;
            disposable.is_lambda = true;
        } else {
            auto target_address = reinterpret_cast<std::size_t>(*target);
            slots.insert(typename slot_map_type::value_type(target_address, slot));
            
            disposable.target = target_address;
            disposable.is_lambda = false;
        }

        return disposable;
    }

    void Remove(slot_type slot) const {
        auto target = slot.template target<target_type>();
        auto target_address = reinterpret_cast<std::size_t>(*target);

        slots.erase(target_address);
    }

    void Remove(const Disposable& disposable) const {
        if(disposable.is_lambda) {
            lambda_slots.erase(disposable.target);
        } else {
            slots.erase(disposable.target);
        }
    }

    void operator()(T... args) {
        for(auto& slot : slots) {
            slot.second(args...);
        }
    }
};


template<>
class Signal<void> {
  public:
    typedef Signal<void> type;
    typedef std::function<void(void)> slot_type;
    typedef void (*target_type)();

    class Disposable {
        friend class Signal;
        std::size_t target;
        bool is_lambda;
    };

  private:
    typedef std::unordered_map<std::size_t, slot_type> slot_map_type;
    mutable slot_map_type slots;
    mutable slot_map_type lambda_slots;
    mutable std::size_t lambda_counter;

  public:
    Signal() : lambda_counter(0) {}
    ~Signal() {}

    Disposable Add(slot_type slot) const {
        Disposable disposable;
        
        auto target = slot.target<target_type>();

        if(target == 0) {
            auto lambda_id = lambda_counter++;
            lambda_slots.insert(slot_map_type::value_type(lambda_id, slot));

            disposable.target = lambda_id;
            disposable.is_lambda = true;
        } else {
            auto target_address = reinterpret_cast<std::size_t>(*target);
            slots.insert(slot_map_type::value_type(target_address, slot));
            
            disposable.target = target_address;
            disposable.is_lambda = false;
        }

        return disposable;
    }

    void Remove(slot_type slot) const {
        auto target = slot.target<target_type>();
        auto target_address = reinterpret_cast<std::size_t>(*target);

        slots.erase(target_address);
    }

    void Remove(const Disposable& disposable) const {
        if(disposable.is_lambda) {
            lambda_slots.erase(disposable.target);
        } else {
            slots.erase(disposable.target);
        }
    }

    void operator()() {
        for(auto& slot : slots) {
            slot.second();
        }
    }
};

} // namespace SPP

#endif  // SIGNALS_CPP_H_